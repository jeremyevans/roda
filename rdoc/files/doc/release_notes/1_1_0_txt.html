<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>1.1.0.txt</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>1.1.0.txt
</h1>
<div class='paths'>
doc/release_notes/1.1.0.txt
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-New+Plugins">New Plugins<span><a href="#label-New+Plugins">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>An assets plugin has been added, for rendering your CSS and javascript asset files on the fly in development, and compiling them to a single, compressed file in production.</p>

<p>When loading the plugin, you just specify the assets to use via :css and/or :js options:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:assets</span>, <span class="ruby-value">:css</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;some_file.scss&#39;</span>, <span class="ruby-value">:js</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;some_file.coffee&#39;</span>
</pre>

<p>Inside your Roda.route block, you call r.assets to serve the assets:</p>

<pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">assets</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In your views, you can call the assets method, which returns strings containing link/script tags for your assets:</p>

<pre>&lt;%= assets(:css) %&gt;
&lt;%= assets(:js) %&gt;</pre>

<p>In production mode, you call compile_assets after loading the plugin, and it will compile all of the asset files into a single file per type, optionally compress it (using yuicompressor), and write the file to the public folder where it can be served by the webserver.  In compiled mode, calling assets in your views will reference the compiled file.</p>

<p>It’s possible to precompile your assets before application boot, so they don’t need to be compiled every time your application boots.</p>

<p>The assets plugin also supports asset groups, useful when different sections of your application use different sets of assets.</p>
</li><li>
<p>A chunked plugin has been added, for streaming template rendering using Transfer-Encoding: chunked.  By default, this flushes the rendering of the top part of the layout template before rendering the content template, allowing the client to load the assets necessary to fully render the page while the content template is still being rendered on the server.  This can significantly decrease client rendering times.</p>

<p>To use chunked encoding for a response, just call the chunked method instead of view:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:index</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>If you want to execute code after flushing the top part of the layout template, but before rendering the content template, pass a block to chunked:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:index</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># expensive calculation here</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>If you want to use chunked encoding for all responses, pass the :chunk_by_default option when loading the plugin:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:chunked</span>, <span class="ruby-value">:chunk_by_default</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">true</span>
</pre>

<p>Inside your layout or content templates, you can call the flush method to flush the current result of the template to the user, useful for streaming large datasets.</p>

<pre>&lt;% (1..100).each do |i| %&gt;
  &lt;%= i %&gt;
  &lt;% sleep 0.1 %&gt;
  &lt;% flush %&gt;
&lt;% end %&gt;</pre>
</li><li>
<p>A caching plugin has been added, for simple HTTP caching support. The implementation is based on Sinatra’s, and offers r.last_modifed and r.etag methods for conditional responses:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;/albums/:d&#39;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_id</span><span class="ruby-operator">|</span>
  <span class="ruby-ivar">@album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-identifier">album_id</span>]
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">last_modified</span> <span class="ruby-ivar">@album</span>.<span class="ruby-identifier">updated_at</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">etag</span> <span class="ruby-ivar">@album</span>.<span class="ruby-identifier">sha1</span>
  <span class="ruby-identifier">view</span>(<span class="ruby-string">&#39;album&#39;</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>This also adds response.cache_control and response.expires methods for setting the Cache-Control/Expires headers for the response.</p>
</li><li>
<p>A path plugin has been added for simple support for named paths:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:path</span>
<span class="ruby-identifier">path</span> <span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;/foo&#39;</span>   <span class="ruby-comment"># foo_path =&gt; &#39;/foo&#39;</span>
<span class="ruby-identifier">path</span> <span class="ruby-value">:bar</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">bar</span><span class="ruby-operator">|</span>  <span class="ruby-comment"># bar_path(bar) =&gt; &#39;/bar/1&#39;</span>
  <span class="ruby-node">&quot;/bar/#{bar.id}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>An error_email plugin has been added, for easily emailing error notifications for an exception.  This is designed for use with the error_handler plugin, and should only be used in low-traffic environments:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:error_email</span>, <span class="ruby-value">:to</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;to@example.com&#39;</span>,
                     <span class="ruby-value">:from</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;from@example.com&#39;</span>
<span class="ruby-identifier">plugin</span> <span class="ruby-value">:error_handler</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">error_email</span>(<span class="ruby-identifier">e</span>)
  <span class="ruby-string">&#39;Internal Server Error&#39;</span>
<span class="ruby-keyword">end</span>
</pre>
</li></ul>

<h1 id="label-multi_route+Plugin+Improvements">multi_route Plugin Improvements<span><a href="#label-multi_route+Plugin+Improvements">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>The multi_route plugin now supports namespaces, allowing it to support routing trees of arbitrary complexity.  Previously, only a single namespace was supported. For example, if you want to store your named routes in a directory tree:</p>

<pre>/routes/foo.rb
/routes/foo/baz.rb
/routes/foo/quux.rb
/routes/bar.rb
/routes/bar/baz.rb
/routes/bar/quux.rb</pre>

<p>You can load all of the routing files in the routes subdirectory tree, and structure your routing tree as follows:</p>

<pre class="ruby"><span class="ruby-comment"># app.rb</span>
<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># routes/foo.rb</span>
<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">check_foo_access!</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>(<span class="ruby-string">&#39;foo&#39;</span>)
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># routes/bar.rb</span>
<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">check_bar_access!</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>(<span class="ruby-string">&#39;bar&#39;</span>)
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># routes/foo/baz.rb</span>
<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>Newly added named routes are now picked up while running, useful in development when using code reloading.</p>
</li><li>
<p>r.multi_route now ignores non-String named routes, allowing you to only dispatch to the String named routes.  Previously, calling r.multi_route when any non-String names routes were present resulted in an error.</p>
</li><li>
<p>r.multi_route now prefers longer routes to shorter routes if routes have the same prefix.  This can fix behavior if you have named routes such as “foo” and “foo/bar”.</p>
</li><li>
<p>If you don’t pass a block to r.multi_route, it will use the return value of the named route as the block value to return, instead of always returning nil.</p>
</li></ul>

<h1 id="label-Optimizations">Optimizations<span><a href="#label-Optimizations">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>Dispatch speed is slightly improved by using allocate instead of new to create new instances.</p>
</li><li>
<p>Hash allocations in the render plugin have been reduced.</p>
</li></ul>

<h1 id="label-Other+Improvements">Other Improvements<span><a href="#label-Other+Improvements">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>The Roda.route block is now inherited when subclassing, making it possible to subclass a <a href="../../../classes/Roda.html"><code>Roda</code></a> application and have the subclass work without adding a route block.</p>
</li><li>
<p>Middleware added to a <a href="../../../classes/Roda.html"><code>Roda</code></a> app after the Roda.route method is called are now used instead of being ignored.</p>
</li><li>
<p>A response.finish_with_body method has been added, for overriding the response body to use.  This is useful if you want to support arbitrary response bodies.</p>
</li><li>
<p>The render plugin now defaults the locals argument to an empty frozen hash instead of nil when rendering templates via tilt. This is faster as it avoids a hash allocation inside tilt, and also works with broken external tilt templates that require that the locals argument be a hash.</p>
</li><li>
<p>Plugins that ship with <a href="../../../classes/Roda.html"><code>Roda</code></a> no longer set constants inside InstanceMethods.  Instead, the constants are set at the plugin module level.  This is done to avoid polluting the namespace of the application with the constants.  Roda’s policy is that all internal constants inside the <a href="../../../classes/Roda.html"><code>Roda</code></a> namespace are prefixed with <a href="../../../classes/Roda.html"><code>Roda</code></a>, so they don’t pollute the user’s namespace, and setting these constants inside InstanceMethods in plugins violated that policy.</p>
</li></ul>

<h1 id="label-Backwards+Compatibility">Backwards Compatibility<span><a href="#label-Backwards+Compatibility">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>response.write no longer sets a Content-Length header.  Instead, response.finish sets it.  This is faster if you call response.write multiple times, and more correct if you call response.finish without calling response.write.</p>
</li><li>
<p>In the render plugin, modifying render_opts directly is now deprecated and will raise an error in the next major release (the hash will be frozen).  Instead, users should call plugin :render again with a new hash, which will be merged into the existing render_opts hash.</p>
</li><li>
<p>Moving plugin’s constants from InstanceMethods to the plugin level can break applications where the constant was referenced directly. For example, if you were doing:</p>

<pre class="ruby"><span class="ruby-constant">Roda</span><span class="ruby-operator">::</span><span class="ruby-constant">SESSION_KEY</span>
</pre>

<p>to get the constant for the session key, you would now need to use:</p>

<pre class="ruby"><span class="ruby-constant">Roda</span><span class="ruby-operator">::</span><span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span><span class="ruby-operator">::</span><span class="ruby-constant">SESSION_KEY</span>
</pre>

<p>In general, it is recommended to not reference such constants at all.  If you think there should be a general reason to access them, request that a method is added that returns them.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>3.79.0.txt</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>3.79.0.txt
</h1>
<div class='paths'>
doc/release_notes/3.79.0.txt
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-New+Features"><a href="#label-New+Features">New Features</a></h1>
<ul><li>
<p>The <a href="../../lib/roda/plugins/hmac_paths_rb.html">hmac_paths</a> plugin allows protection of paths using an HMAC.  This can be used to prevent users enumerating paths, since only paths with valid HMACs will be respected.</p>

<p>To use the plugin, you must provide a :secret option.  This sets the secret for the HMACs.  Make sure to keep this value secret, as this plugin does not provide protection against users who know the secret value.  The secret must be at least 32 bytes.</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:hmac_paths</span>, <span class="ruby-value">secret:</span> <span class="ruby-string">&#39;some-secret-value-with-at-least-32-bytes&#39;</span>
</pre>

<p>To generate a valid HMAC path, you call the hmac_path method:</p>

<pre class="ruby"><span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/widget/1&#39;</span>)
<span class="ruby-comment"># =&gt; &quot;/0c2feaefdfc80cc73da19b060c713d4193c57022815238c6657ce2d99b5925eb/0/widget/1&quot;</span>
</pre>

<p>The first segment in the returned path is the HMAC.  The second segment is flags for the type of paths (see below), and the rest of the path is as given.</p>

<p>To protect a path or any subsection in the routing tree, you wrap the related code in an <code>r.hmac_path</code> block.</p>

<pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hmac_path</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;widget&#39;</span>, <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">widget_id</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># ...</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>If first segment of the remaining path contains a valid HMAC for the rest of the path (considering the flags), then r.hmac_path will match and yield to the block, and routing continues inside the block with the HMAC and flags segments removed.</p>

<p>In the above example, if you provide a user a link for widget with ID 1, there is no way for them to guess the valid path for the widget with ID 2, preventing a user from enumerating widgets, without relying on custom access control.  Users can only access paths that have been generated by the application and provided to them, either directly or indirectly.</p>

<p>In the above example, r.hmac_path is used at the root of the routing tree. If you would like to call it below the root of the routing tree, it works correctly, but you must pass hmac_path the :root option specifying where r.hmac_paths will be called from. Consider this example:</p>

<pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&#39;widget&#39;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hmac_path</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">widget_id</span><span class="ruby-operator">|</span>
        <span class="ruby-comment"># ...</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&#39;foobar&#39;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hmac_path</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">foobar_id</span><span class="ruby-operator">|</span>
        <span class="ruby-comment"># ...</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>For security reasons, the hmac_path plugin does not allow an HMAC path designed for widgets to be a valid match in the r.hmac_path call inside the “r.on ‘foobar’” block, preventing users who have a valid HMAC for a widget from looking at the page for a foobar with the same ID.  When generating HMAC paths where the matching r.hmac_path call is not at the root of the routing tree, you must pass the :root option:</p>

<pre class="ruby"><span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/1&#39;</span>, <span class="ruby-value">root:</span> <span class="ruby-string">&#39;/widget&#39;</span>)
<span class="ruby-comment"># =&gt; &quot;/widget/daccafce3ce0df52e5ce774626779eaa7286085fcbde1e4681c74175ff0bbacd/0/1&quot;</span>

<span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/1&#39;</span>, <span class="ruby-value">root:</span> <span class="ruby-string">&#39;/foobar&#39;</span>)
<span class="ruby-comment"># =&gt; &quot;/foobar/c5fdaf482771d4f9f38cc13a1b2832929026a4ceb05e98ed6a0cd5a00bf180b7/0/1&quot;</span>
</pre>

<p>Note how the HMAC changes even though the path is the same.</p>

<p>In addition to the <code>:root</code> option, there are additional options that further constrain use of the generated paths.</p>

<p>The :method option creates a path that can only be called with a certain request method:</p>

<pre class="ruby"><span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/widget/1&#39;</span>, <span class="ruby-value">method:</span> <span class="ruby-value">:get</span>)
<span class="ruby-comment"># =&gt; &quot;/d38c1e634ecf9a3c0ab9d0832555b035d91b35069efcbf2670b0dfefd4b62fdd/m/widget/1&quot;</span>
</pre>

<p>Note how this results in a different HMAC than the original hmac_path(‘/widget/1’) call.  This sets the flags segment to “m”, which means r.hmac_path will consider the request mehod when checking the HMAC, and will only match if the provided request method is GET.  This allows you to provide a user the ability to submit a GET request for the underlying path, without providing them the ability to submit a POST request for the underlying path, with no other access control.</p>

<p>The :params option accepts a hash of params, converts it into a query string, and includes the query string in the returned path.  It sets the flags segment to <code>p</code>, which means r.hmac_path will check for that exact query string.  Requests with an empty query string or a different string will not match.</p>

<pre class="ruby"><span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/widget/1&#39;</span>, <span class="ruby-value">params:</span> {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>})
<span class="ruby-comment"># =&gt; &quot;/fe8d03f9572d5af6c2866295bd3c12c2ea11d290b1cbd016c3b68ee36a678139/p/widget/1?foo=bar&quot;</span>
</pre>

<p>For GET requests, which cannot have request bodies, that is sufficient to ensure that the submitted params are exactly as specified. However, POST requests can have request bodies, and request body params override query string params in r.params.  So if you are using this for POST requests (or other HTTP verbs that can have request bodies), use r.GET instead of r.params to specifically check query string parameters.</p>

<p>You can use <code>:root</code>, <code>:method</code>, and <code>:params</code> at the same time:</p>

<pre class="ruby"><span class="ruby-identifier">hmac_path</span>(<span class="ruby-string">&#39;/1&#39;</span>, <span class="ruby-value">root:</span> <span class="ruby-string">&#39;/widget&#39;</span>, <span class="ruby-value">method:</span> <span class="ruby-value">:get</span>, <span class="ruby-value">params:</span> {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>})
<span class="ruby-comment"># =&gt; &quot;/widget/9169af1b8f40c62a1c2bb15b1b377c65bda681b8efded0e613a4176387468c15/mp/1?foo=bar&quot;</span>
</pre>

<p>This gives you a path only valid for a GET request with a root of “/widget” and a query string of “foo=bar”.</p>

<p>To handle secret rotation, you can provide an :old_secret option when loading the plugin.</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:hmac_paths</span>, <span class="ruby-value">secret:</span> <span class="ruby-string">&#39;some-secret-value-with-at-least-32-bytes&#39;</span>,
                    <span class="ruby-value">old_secret:</span> <span class="ruby-string">&#39;previous-secret-value-with-at-least-32-bytes&#39;</span>
</pre>

<p>This will use :secret for constructing new paths, but will respect paths generated by :old_secret.</p>
</li></ul>

<h1 id="label-Other+Improvements"><a href="#label-Other+Improvements">Other Improvements</a></h1>
<ul><li>
<p>When not using cached templates in the render plugin, the render plugin now has better handling when a template is modified and results in an error.  Previously, the error would be raised on the first request after the template modification, but subsequent requests would use the previous template value.  The render plugin will no longer update the last modified time in this case, so if a template is modified and introduces an error (e.g. SyntaxError in an erb template), all future requests that use the template will result in the error being raised, until the template is fixed.</p>
</li></ul>

<h1 id="label-Backwards+Compatibility"><a href="#label-Backwards+Compatibility">Backwards Compatibility</a></h1>
<ul><li>
<p>The internal TemplateMtimeWrapper API has been modified.  As documented, this is an internal class and the API can change in any <a href="../../../classes/Roda.html"><code>Roda</code></a> version. However, if any code was relying on the previous implementation of TemplateMtimeWrapper#modified?, it will need to be modified, as that method has been replaced with TemplateMtimeWrapper#if_modified.</p>

<p>Additionally, the TemplateMtimeWrapper#compiled_method_lambda API has also changed.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>

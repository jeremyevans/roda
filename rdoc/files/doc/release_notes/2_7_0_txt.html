<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>2.7.0.txt</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>2.7.0.txt
</h1>
<div class='paths'>
doc/release_notes/2.7.0.txt
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-New+Features">New Features<span><a href="#label-New+Features">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>A default_status plugin has been added for changing the default status for responses.  Previously, the default status was hard coded to 200, this plugin allows you to change it.  The plugin takes a block which is instance_evaled in the context of the response:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:default_status</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Content-Type&#39;</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-value">201</span> <span class="ruby-operator">:</span> <span class="ruby-value">200</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Note that the default status for empty responses (used when no route handles the response) is still 404, this just changes the default for non-empty responses.</p>
</li><li>
<p>A response_request plugin has been added for giving the response instance access to the related request.  This can be useful in conjunction with the default_status plugin, if you want the default status of the response to depend on the request, such as using a different status for different request methods:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:response_request</span>
<span class="ruby-identifier">plugin</span> <span class="ruby-value">:default_status</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">request</span>.<span class="ruby-identifier">post?</span> <span class="ruby-operator">?</span> <span class="ruby-value">201</span> <span class="ruby-operator">:</span> <span class="ruby-value">200</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>A run_handler plugin has been added, for modifying rack response arrays before returning them when using r.run.  Additionally, it allows for continuing with routing if the response returned by r.run is a 404 response, using the :not_found=&gt;:pass option:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:run_handler</span>
<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># Keep running code if RackAppFoo returns a 404 response</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">run</span> <span class="ruby-constant">RackAppFoo</span>, <span class="ruby-value">:not_found</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:pass</span>

  <span class="ruby-comment"># Change response status codes before returning.</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">run</span>(<span class="ruby-constant">RackAppBar</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">response</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">response</span>[<span class="ruby-value">0</span>] = <span class="ruby-value">200</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">response</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">201</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>Roda.rewite_path in the path_rewriter extension now accepts a block to allow for dynamic replacements. The block is yielded a MatchData instance:</p>

<pre>rewrite_path(/\A\/a/(\w+)/){|match| match[1].capitalize}
# PATH_INFO &#39;/a/moo&#39; =&gt; remaining_path &#39;/a/Moo&#39;

rewrite_path(/\A\/a/(\w+)/, :path_info =&gt; true) do |match|
  match[1].capitalize
end
# PATH_INFO &#39;/a/moo&#39; =&gt; PATH_INFO &#39;/a/Moo&#39;</pre>
</li><li>
<p>The :host matcher in the header_matchers plugin will now yield the regexp captures to the block if given a regexp when the :host_matcher_captures application option is set.  This behavior will become the default behavior in <a href="../../../classes/Roda.html"><code>Roda</code></a> 3.  This will allow for code like:</p>

<pre class="ruby"><span class="ruby-identifier">opts</span>[<span class="ruby-value">:host_matcher_captures</span>] = <span class="ruby-keyword">true</span>
<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-value">:host</span><span class="ruby-operator">=&gt;</span><span class="ruby-regexp">/\A(\w+).example.com\z/</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">subdomain</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
</li></ul>

<h1 id="label-Other+Improvements">Other Improvements<span><a href="#label-Other+Improvements">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>RodaCache now uses a mutex to synchronize access on MRI. Previously, it relied on the global interpreter lock, but testing has shown that is not reliable in all cases.  RodaCache has always used a mutex for synchronization on other ruby implementations, this just extends that code to MRI as well.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>

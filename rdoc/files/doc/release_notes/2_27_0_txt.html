<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>2.27.0.txt</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>2.27.0.txt
</h1>
<div class='paths'>
doc/release_notes/2.27.0.txt
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-New+Features">New Features<span><a href="#label-New+Features">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>String and Integer class matchers have been added.  The String class matches any non-empty segment and yields it as a string.  This is the same as the behavior of the symbol matchers, but without the duplication.  So instead of:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">is</span> <span class="ruby-string">&quot;album&quot;</span>, <span class="ruby-value">:album_name</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_name</span><span class="ruby-operator">|</span>
<span class="ruby-keyword">end</span>
</pre>

<p>you can now do:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">is</span> <span class="ruby-string">&quot;album&quot;</span>, <span class="ruby-constant">String</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_name</span><span class="ruby-operator">|</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This makes it a bit more intuitive that you want to match any string, and avoids the redundancy between the symbol name and block argument name.</p>

<p>The Integer class matches any integer segment (d+) and yields it as an integer:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">is</span> <span class="ruby-string">&quot;album&quot;</span>, <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_id</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># does not match &quot;/albums/foo&quot;</span>
  <span class="ruby-comment"># matches &quot;/albums/1&quot;, yielding 1 (not &quot;1&quot;)</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Previously, the :d matcher in the symbol_matchers plugin could be used to only match integer segments, but it yielded results as strings and not integers, so you still needed to convert the type manually.  Using Integer is a bit more intuitive than using :d, and it handles the type conversion for you.</p>
</li><li>
<p>A class_matchers plugin has been added for matching additional classes, with user-specified regexps and type conversion.  For example, if you want to match YYYY-MM-DD segments and yield them to the match blocks as ruby Date objects, you can do:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:class_matchers</span>

<span class="ruby-identifier">class_matcher</span>(<span class="ruby-constant">Date</span>, <span class="ruby-regexp">/(\d\d\d\d)-(\d\d)-(\d\d)/</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">y</span>, <span class="ruby-identifier">m</span>, <span class="ruby-identifier">d</span><span class="ruby-operator">|</span>
  [<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">y</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_i</span>)]
<span class="ruby-keyword">end</span>
</pre>

<p>and then in your routing tree, you can do:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&quot;posts&quot;</span>, <span class="ruby-constant">Date</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">date</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># does not match &quot;/posts/foo&quot; or &quot;/posts/2017-01&quot;</span>
  <span class="ruby-comment"># matches &quot;/posts/2017-01-13&quot;, yielding Date.new(2017, 1, 13)</span>
<span class="ruby-keyword">end</span>
</pre>
</li></ul>

<h1 id="label-Backwards+Compatibility">Backwards Compatibility<span><a href="#label-Backwards+Compatibility">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>If you were using the Integer and String classes as matchers before and expected them to always match, youâ€™ll need to change your code to use true instead.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Roda::RodaPlugins::TypecastParams</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Roda::RodaPlugins::TypecastParams
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/roda/plugins/typecast_params_rb.html">lib/roda/plugins/typecast_params.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The typecast_params plugin allows for type conversion of submitted parameters. Submitted parameters should be considered untrusted input, and in standard use with browsers, parameters are # submitted as strings (or a hash/array containing strings).  In most # cases it makes sense to explicitly convert the parameter to the desired type.  While this can be done via manual conversion:</p>

<pre class="ruby"><span class="ruby-identifier">val</span> = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;key&#39;</span>].<span class="ruby-identifier">to_i</span>
<span class="ruby-identifier">val</span> = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
</pre>

<p>the typecast_params plugin adds a friendlier interface:</p>

<pre class="ruby"><span class="ruby-identifier">val</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key&#39;</span>)
</pre>

<p>As <code>typecast_params</code> is a fairly long method name, and may be a method you call frequently, you may want to consider aliasing it to something more terse in your application, such as <code>tp</code>.</p>

<p>typecast_params offers support for default values:</p>

<pre class="ruby"><span class="ruby-identifier">val</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">1</span>)
</pre>

<p>The default value is only used if no value has been submitted for the parameter, or if the conversion of the value results in <code>nil</code>.  Handling defaults for parameter conversion manually is more difficult, since the parameter may not be present at all, or it may be present but an empty string because the user did not enter a value on the related form.  Use of typecast_params for the conversion handles both cases.</p>

<p>In many cases, parameters should be required, and if they aren’t submitted, that should be considered an error.  typecast_params handles this with ! methods:</p>

<pre class="ruby"><span class="ruby-identifier">val</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;key&#39;</span>)
</pre>

<p>These ! methods raise an error instead of returning <code>nil</code>, and do not allow defaults.</p>

<p>The errors raised by this plugin use a specific exception class, <a href="TypecastParams/Error.html"><code>Roda::RodaPlugins::TypecastParams::Error</code></a>.  This allows you to handle this specific exception class globally and return an appropriate 4xx response to the client.  You can use the <a href="TypecastParams/Error.html#method-i-param_name"><code>Error#param_name</code></a> and <a href="TypecastParams/Error.html#attribute-i-reason"><code>Error#reason</code></a> methods to get more information about the error.</p>

<p>To make it easy to handle cases where many parameters need the same conversion done, you can pass an array of keys to a conversion method, and it will return an array of converted values:</p>

<pre class="ruby"><span class="ruby-identifier">val1</span>, <span class="ruby-identifier">val2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>([<span class="ruby-string">&#39;key1&#39;</span>, <span class="ruby-string">&#39;key2&#39;</span>])
</pre>

<p>This is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">val1</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key1&#39;</span>)
<span class="ruby-identifier">val2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key2&#39;</span>)
</pre>

<p>The ! methods also support arrays, ensuring that all parameters have a value:</p>

<pre class="ruby"><span class="ruby-identifier">val1</span>, <span class="ruby-identifier">val2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;key1&#39;</span>, <span class="ruby-string">&#39;key2&#39;</span>])
</pre>

<p>For handling of array parameters, where all entries in the array use the same conversion, there is an <code>array</code> method which takes the type as the first argument and the keys to convert as the second argument:</p>

<pre class="ruby"><span class="ruby-identifier">vals</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>)
</pre>

<p>If you want to ensure that all entries in the array are converted successfully and that there is a value for the array itself, you can use <code>array!</code>:</p>

<pre class="ruby"><span class="ruby-identifier">vals</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>)
</pre>

<p>This will raise an exception if any of the values in the array for parameter <code>keys</code> cannot be converted to integer.</p>

<p>Both <code>array</code> and <code>array!</code> support default values which are used if no value is present for the parameter:</p>

<pre class="ruby"><span class="ruby-identifier">vals1</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys1&#39;</span>, [])
<span class="ruby-identifier">vals2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys2&#39;</span>, [])
</pre>

<p>You can also pass an array of keys to <code>array</code> or <code>array!</code>, if you would like to perform the same conversion on multiple arrays:</p>

<pre class="ruby"><span class="ruby-identifier">foo_ids</span>, <span class="ruby-identifier">bar_ids</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, [<span class="ruby-string">&#39;foo_ids&#39;</span>, <span class="ruby-string">&#39;bar_ids&#39;</span>])
</pre>

<p>The previous examples have shown use of the <code>pos_int</code> method, which uses <code>to_i</code> to convert the value to an integer, but returns <code>nil</code> if the resulting integer is not positive.  Unless you need to handle negative numbers, it is recommended to use <code>pos_int</code> instead of <code>int</code> as <code>int</code> will convert invalid values to 0 (since that is how <code>String#to_i</code> works).</p>

<p>There are many built in methods for type conversion:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>any </td><td>
<p>Returns the value as is without conversion</p>
</td></tr><tr><td class='label'>str </td><td>
<p>Raises if value is not already a string</p>
</td></tr><tr><td class='label'>nonempty_str </td><td>
<p>Raises if value is not already a string, and converts the empty string or string containing only whitespace to <code>nil</code></p>
</td></tr><tr><td class='label'>bool </td><td>
<p>Converts entry to boolean if in one of the recognized formats:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>nil </td><td>
<p>nil, ”</p>
</td></tr><tr><td class='label'>true </td><td>
<p>true, 1, ‘1’, ‘t’, ‘true’, ‘yes’, ‘y’, ‘on’ # case insensitive</p>
</td></tr><tr><td class='label'>false </td><td>
<p>false, 0, ‘0’, ‘f’, ‘false’, ‘no’, ‘n’, ‘off’ # case insensitive</p>
</td></tr></tbody></table>

<p>If not in one of those formats, raises an error.</p>
</td></tr><tr><td class='label'>int </td><td>
<p>Converts value to integer using <code>to_i</code> (note that invalid input strings will be returned as 0)</p>
</td></tr><tr><td class='label'>pos_int </td><td>
<p>Converts value using <code>to_i</code>, but non-positive values are converted to <code>nil</code></p>
</td></tr><tr><td class='label'>Integer </td><td>
<p>Converts value to integer using <code>Kernel::Integer</code>, with base 10 for string inputs, and a check that the output value is equal to the input value for numeric inputs.</p>
</td></tr><tr><td class='label'>float </td><td>
<p>Converts value to float using <code>to_f</code> (note that invalid input strings will be returned as 0.0)</p>
</td></tr><tr><td class='label'>Float </td><td>
<p>Converts value to float using <code>Kernel::Float(value)</code></p>
</td></tr><tr><td class='label'>Hash </td><td>
<p>Raises if value is not already a hash</p>
</td></tr><tr><td class='label'>date </td><td>
<p>Converts value to Date using <code>Date.parse(value)</code></p>
</td></tr><tr><td class='label'>time </td><td>
<p>Converts value to Time using <code>Time.parse(value)</code></p>
</td></tr><tr><td class='label'>datetime </td><td>
<p>Converts value to DateTime using <code>DateTime.parse(value)</code></p>
</td></tr><tr><td class='label'>file </td><td>
<p>Raises if value is not already a hash with a :tempfile key whose value responds to <code>read</code> (this is the format rack uses for uploaded files).</p>
</td></tr></tbody></table>

<p>All of these methods also support ! methods (e.g. <code>pos_int!</code>), and all of them can be used in the <code>array</code> and <code>array!</code> methods to support arrays of values.</p>

<p>Since parameter hashes can be nested, the <code>[]</code> method can be used to access nested hashes:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;{&#39;sub_key&#39;=&gt;&#39;1&#39;}}</span>
<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>This works to an arbitrary depth:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;{&#39;sub_key&#39;=&gt;{&#39;sub_sub_key&#39;=&gt;&#39;1&#39;}}}</span>
<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-string">&#39;sub_key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>And also works with arrays at any depth, if those arrays contain hashes:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;[{&#39;sub_key&#39;=&gt;{&#39;sub_sub_key&#39;=&gt;&#39;1&#39;}}]}</span>
<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-value">0</span>][<span class="ruby-string">&#39;sub_key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>

<span class="ruby-comment"># params: {&#39;key&#39;=&gt;[{&#39;sub_key&#39;=&gt;[&#39;1&#39;]}]}</span>
<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-value">0</span>].<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;sub_key&#39;</span>) <span class="ruby-comment"># =&gt; [1]</span>
</pre>

<p>To allow easier access to nested data, there is a <code>dig</code> method:</p>

<pre class="ruby"><span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-string">&#39;sub_key&#39;</span>)
<span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-string">&#39;sub_key&#39;</span>, <span class="ruby-string">&#39;sub_sub_key&#39;</span>)
</pre>

<p><code>dig</code> will return <code>nil</code> if any access while looking up the nested value returns <code>nil</code>. There is also a <code>dig!</code> method, which will raise an <a href="TypecastParams/Error.html"><code>Error</code></a> if <code>dig</code> would return <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-string">&#39;sub_key&#39;</span>)
<span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-string">&#39;sub_key&#39;</span>, <span class="ruby-string">&#39;sub_sub_key&#39;</span>)
</pre>

<p>Note that none of these conversion methods modify <code>request.params</code>.  They purely do the conversion and return the converted value.  However, in some cases it is useful to do all the conversion up front, and then pass a hash of converted parameters to an internal method that expects to receive values in specific types.  The <code>convert!</code> method does this, and there is also a <code>convert_each!</code> method designed for converting multiple values using the same block:</p>

<pre class="ruby"><span class="ruby-identifier">converted_params</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">convert!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tp</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">int</span>(<span class="ruby-string">&#39;page&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;artist_id&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;album_ids&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;sales&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;num_sold&#39;</span>, <span class="ruby-string">&#39;num_shipped&#39;</span>])
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;members&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mtp</span>.<span class="ruby-identifier">convert_each!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">str!</span>([<span class="ruby-string">&#39;first_name&#39;</span>, <span class="ruby-string">&#39;last_name&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># converted_params:</span>
<span class="ruby-comment"># {</span>
<span class="ruby-comment">#   &#39;page&#39; =&gt; 1,</span>
<span class="ruby-comment">#   &#39;artist_id&#39; =&gt; 2,</span>
<span class="ruby-comment">#   &#39;album_ids&#39; =&gt; [3, 4],</span>
<span class="ruby-comment">#   &#39;sales&#39; =&gt; {</span>
<span class="ruby-comment">#     &#39;num_sold&#39; =&gt; 5,</span>
<span class="ruby-comment">#     &#39;num_shipped&#39; =&gt; 6</span>
<span class="ruby-comment">#   },</span>
<span class="ruby-comment">#   &#39;members&#39; =&gt; [</span>
<span class="ruby-comment">#      {&#39;first_name&#39; =&gt; &#39;Foo&#39;, &#39;last_name&#39; =&gt; &#39;Bar&#39;},</span>
<span class="ruby-comment">#      {&#39;first_name&#39; =&gt; &#39;Baz&#39;, &#39;last_name&#39; =&gt; &#39;Quux&#39;}</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment"># }</span>
</pre>

<p><code>convert!</code> and <code>convert_each!</code> only return values you explicitly specify for conversion inside the passed block.</p>

<p>You can specify the <code>:symbolize</code> option to <code>convert!</code> or <code>convert_each!</code>, which will symbolize the resulting hash keys:</p>

<pre class="ruby"><span class="ruby-identifier">converted_params</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-value">symbolize:</span> <span class="ruby-keyword">true</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tp</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">int</span>(<span class="ruby-string">&#39;page&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;artist_id&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;album_ids&#39;</span>)
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;sales&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;num_sold&#39;</span>, <span class="ruby-string">&#39;num_shipped&#39;</span>])
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;members&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mtp</span>.<span class="ruby-identifier">convert_each!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">str!</span>([<span class="ruby-string">&#39;first_name&#39;</span>, <span class="ruby-string">&#39;last_name&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># converted_params:</span>
<span class="ruby-comment"># {</span>
<span class="ruby-comment">#   :page =&gt; 1,</span>
<span class="ruby-comment">#   :artist_id =&gt; 2,</span>
<span class="ruby-comment">#   :album_ids =&gt; [3, 4],</span>
<span class="ruby-comment">#   :sales =&gt; {</span>
<span class="ruby-comment">#     :num_sold =&gt; 5,</span>
<span class="ruby-comment">#     :num_shipped =&gt; 6</span>
<span class="ruby-comment">#   },</span>
<span class="ruby-comment">#   :members =&gt; [</span>
<span class="ruby-comment">#      {:first_name =&gt; &#39;Foo&#39;, :last_name =&gt; &#39;Bar&#39;},</span>
<span class="ruby-comment">#      {:first_name =&gt; &#39;Baz&#39;, :last_name =&gt; &#39;Quux&#39;}</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment"># }</span>
</pre>

<p>Using the <code>:symbolize</code> option makes it simpler to transition from untrusted external data (string keys), to semitrusted data that can be used internally (trusted in the sense that the expected types are used, not that you trust the values).</p>

<p>Note that if there are multiple conversion errors raised inside a <code>convert!</code> or <code>convert_each!</code> block, they are recorded and a single <a href="TypecastParams/Error.html"><code>TypecastParams::Error</code></a> instance is raised after processing the block.  <a href="TypecastParams/Error.html#method-i-param_names"><code>TypecastParams::Error#param_names</code></a> can be called on the exception to get an array of all parameter names with conversion issues, and <a href="TypecastParams/Error.html#method-i-all_errors"><code>TypecastParams::Error#all_errors</code></a> can be used to get an array of all <a href="TypecastParams/Error.html"><code>Error</code></a> instances.</p>

<p>Because of how <code>convert!</code> and <code>convert_each!</code> work, you should avoid calling <a href="TypecastParams/Params.html#method-i-5B-5D"><code>TypecastParams::Params#[]</code></a> inside the block you pass to these methods, because if the [] call fails, it will skip the reminder of the block.</p>

<p>Be aware that when you use <code>convert!</code> and <code>convert_each!</code>, the conversion methods called inside the block may return nil if there is a error raised, and nested calls to <code>convert!</code> and <code>convert_each!</code> may not return values.</p>

<p>When loading the typecast_params plugin, a subclass of <a href="TypecastParams/Params.html"><code>TypecastParams::Params</code></a> is created specific to the <a href="../../Roda.html"><code>Roda</code></a> application.  You can add support for custom types by passing a block when loading the typecast_params plugin.  This block is executed in the context of the subclass, and calling <code>handle_type</code> in the block can be used to add conversion methods. <code>handle_type</code> accepts a type name, an options hash, and the block used to convert the type. Supported options are:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'><code>:invalid_value_message</code> </td><td>
<p>The message to use for type conversions that result in a nil value (a space and the parameter name is appended to this).</p>
</td></tr><tr><td class='label'><code>:max_input_bytesize</code> </td><td>
<p>The maximum bytesize of string input.</p>
</td></tr></tbody></table>

<p>You can override the invalid value message of an existing type using the <code>invalid_value_message</code> method.  You can also override the max input bytesize of an existing type using the <code>max_input_bytesize</code> method.</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:typecast_params</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">handle_type</span>(<span class="ruby-value">:album</span>, <span class="ruby-value">max_input_bytesize:</span> <span class="ruby-value">100</span>,
              <span class="ruby-value">invalid_value_message:</span> <span class="ruby-string">&quot;invalid album id in parameter&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">id</span> = <span class="ruby-identifier">convert_pos_int</span>(<span class="ruby-identifier">val</span>)
      <span class="ruby-constant">Album</span>[<span class="ruby-identifier">id</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">max_input_bytesize</span>(<span class="ruby-value">:date</span>, <span class="ruby-value">256</span>)
  <span class="ruby-identifier">invalid_value_message</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&quot;value must be greater than 0 for parameter&quot;</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>By default, the typecast_params conversion procs are passed the parameter value directly from <code>request.params</code> without modification.  In some cases, it may be beneficial to strip leading and trailing whitespace from parameter string values before processing, which you can do by passing the <code>strip: :all</code> option when loading the plugin.</p>

<p>By default, the typecasting methods for some types check whether the bytesize of input strings is over the maximum expected values, and raise an error in such cases. The input bytesize is checked prior to any type conversion.  If you would like to skip this check and allow any bytesize when doing type conversion for param string values, you can do so by passing the # <code>:skip_bytesize_checking</code> option when loading the plugin. By default, there is an 100 byte limit on integer input, an 1000 byte input on float input, and a 128 byte limit on date/time input.</p>

<p>By default, the typecasting methods check whether input strings have null bytes, and raise an error in such cases.  This check for null bytes occurs prior to any type conversion. If you would like to skip this check and allow null bytes in param string values, you can do so by passing the <code>:allow_null_bytes</code> option when loading the plugin.</p>

<p>You can use the :date_parse_input_handler option to specify custom handling of date parsing input.  Modern versions of Ruby and the date gem internally raise if the input to date parsing methods is too large to prevent denial of service.  If you are using an older version of Ruby, you can use this option to enforce the same check:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:typecast_params</span>, <span class="ruby-value">date_parse_input_handler:</span> <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;too big&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">string</span>.<span class="ruby-identifier">bytesize</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">128</span>
    <span class="ruby-identifier">string</span>
  }
</pre>

<p>You can also use this option to modify the input, such as truncating it to the first 128 bytes:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:typecast_params</span>, <span class="ruby-value">date_parse_input_handler:</span> <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">string</span>.<span class="ruby-identifier">b</span>[<span class="ruby-value">0</span>, <span class="ruby-value">128</span>]
  }
</pre>

<p>The <code>date_parse_input_handler</code> is only called if the value is under the max input bytesize, so you may need to call <code>max_input_bytesize</code> for the <code>:date</code>, <code>:time</code>, and <code>:datetime</code> methods to override the max input bytesize if you want to use this option for input strings over 128 bytes.</p>

<p>By design, typecast_params only deals with string keys, it is not possible to use symbol keys as arguments to the conversion methods and have them converted.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-configure">configure</a></li>
</ol>
</div>
<div id='context'>
<div id='includes'>
<h2>Included modules</h2>
<ol>
<li><a href="TypecastParams/DateParseInputHandler.html">DateParseInputHandler</a></li>
</ol>
</div>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="TypecastParams/AllowNullByte.html">Roda::RodaPlugins::TypecastParams::AllowNullByte</a></li>
<li><a href="TypecastParams/ClassMethods.html">Roda::RodaPlugins::TypecastParams::ClassMethods</a></li>
<li><a href="TypecastParams/DateParseInputHandler.html">Roda::RodaPlugins::TypecastParams::DateParseInputHandler</a></li>
<li><a href="TypecastParams/InstanceMethods.html">Roda::RodaPlugins::TypecastParams::InstanceMethods</a></li>
<li><a href="TypecastParams/SkipBytesizeChecking.html">Roda::RodaPlugins::TypecastParams::SkipBytesizeChecking</a></li>
<li><a href="TypecastParams/StringStripper.html">Roda::RodaPlugins::TypecastParams::StringStripper</a></li>
<li><a href="TypecastParams/Error.html">Roda::RodaPlugins::TypecastParams::Error</a></li>
<li><a href="TypecastParams/Params.html">Roda::RodaPlugins::TypecastParams::Params</a></li>
<li><a href="TypecastParams/ProgrammerError.html">Roda::RodaPlugins::TypecastParams::ProgrammerError</a></li>
</ol>
</div>
<div id='section'>
<div id='constants-list'>
<h2>Constants</h2>
<div class='name-list'>
<table summary='Constants'>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>CHECK_NIL</td>
<td>=</td>
<td class='context-item-value'>Object.new.freeze</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Sentinal value for whether to raise exception during process</p>
</td>
</tr>
</table>
</div>
</div>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='method public-class' id='method-method-c-configure'>
<a name='method-c-configure'></a>
<div class='synopsis'>
<span class='name'>configure</span><span class='arguments'>(app, opts=OPTS, &block)</span>

</div>
<div class='description'>

<p>Set application-specific <a href="TypecastParams/Params.html"><code>Params</code></a> subclass unless one has been set, and if a block is passed, eval it in the context of the subclass. Respect the <code>strip: :all</code> to strip all parameter strings before processing them.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-configure-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-configure-source'>     <span class="ruby-comment"># File lib/roda/plugins/typecast_params.rb</span>
<span class="line-num">1121</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">configure</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="line-num">1122</span>   <span class="ruby-identifier">app</span>.<span class="ruby-identifier">const_set</span>(<span class="ruby-value">:TypecastParams</span>, <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span><span class="ruby-operator">::</span><span class="ruby-constant">Params</span>)) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">app</span>.<span class="ruby-identifier">const_defined?</span>(<span class="ruby-value">:TypecastParams</span>)
<span class="line-num">1123</span>   <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">class_eval</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
<span class="line-num">1124</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:strip</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:all</span>
<span class="line-num">1125</span>     <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:include</span>, <span class="ruby-constant">StringStripper</span>)
<span class="line-num">1126</span>   <span class="ruby-keyword">end</span>
<span class="line-num">1127</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:allow_null_bytes</span>]
<span class="line-num">1128</span>     <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:include</span>, <span class="ruby-constant">AllowNullByte</span>)
<span class="line-num">1129</span>   <span class="ruby-keyword">end</span>
<span class="line-num">1130</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:skip_bytesize_checking</span>]
<span class="line-num">1131</span>     <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:include</span>, <span class="ruby-constant">SkipBytesizeChecking</span>)
<span class="line-num">1132</span>   <span class="ruby-keyword">end</span>
<span class="line-num">1133</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:date_parse_input_handler</span>]
<span class="line-num">1134</span>     <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
<span class="line-num">1135</span>       <span class="ruby-identifier">include</span> <span class="ruby-constant">DateParseInputHandler</span>
<span class="line-num">1136</span>       <span class="ruby-identifier">define_method</span>(<span class="ruby-value">:handle_date_parse_input</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">opts</span>[<span class="ruby-value">:date_parse_input_handler</span>])
<span class="line-num">1137</span>       <span class="ruby-identifier">private</span> <span class="ruby-value">:handle_date_parse_input</span>
<span class="line-num">1138</span>       <span class="ruby-keyword">alias</span> <span class="ruby-identifier">handle_date_parse_input</span> <span class="ruby-identifier">handle_date_parse_input</span>
<span class="line-num">1139</span>     <span class="ruby-keyword">end</span>
<span class="line-num">1140</span>   <span class="ruby-keyword">end</span>
<span class="line-num">1141</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
